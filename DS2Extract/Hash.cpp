#include "Hash.h"
#include "StdLib.h"
#include "Base.h"
#include "Memory.h"

static unsigned char g_Lower_Char[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};

wchar_t*	g_pUnicodeLowercaseCache	= NULL;
int			g_UnicodeLowercaseCacheSize	= 0;

HASHKEY GetHashInsensitive(const char *pStr, int len, HASHKEY initial_val, BOOL post_process){
	HASHKEY res, k;
	int j;
	char *s = (char*)pStr;
	if (pStr && len){
		j = len & 3;
		res = initial_val;

		if ((len >>= 2)){
			do  {
				res += (char)g_Lower_Char[*s] | ((char)g_Lower_Char[*(s+1)]<<8);
				k = (char)g_Lower_Char[*(s+2)] | ((char)g_Lower_Char[*(s+3)]<<8);

				res += (res ^= ((k ^ (res << 5)) << 11)) >> 11;

				s += 4;
				len--;
			} while (len);
		}
		if (!(--j)){
			res += ((char)g_Lower_Char[*s]);
			res += (res ^= (res << 10)) >> 1;
		} else if (!(--j)){
			res += (char)g_Lower_Char[*s] | ((char)g_Lower_Char[*(s+1)]<<8);
			res += (res ^= (res << 11)) >> 17;
		} else if (!(--j)){
			res += (char)g_Lower_Char[*s] | ((char)g_Lower_Char[*(s+1)]<<8);
			res += (res ^= ((((char)g_Lower_Char[*(s+2)] << 2) ^ res) << 16)) >> 11;
		}
	} else
		res = initial_val;
	if (post_process)
		res ^= (res += (res ^= (res += (res ^= res << 3) >> 5) << 2 ) >> 15) << 10;
	return res;
}

HASHKEY GetHash(const unsigned char *pStr, int len, HASHKEY initial_val, BOOL post_process){
	unsigned long res, k;
	int j;
	char *s = (char*)pStr;
	if (pStr && len){
		j = len & 3;
		res = initial_val;

		if ((len >>= 2)){
			do  {
				res += *s | (*(s+1)<<8);
				k = *(s+2) | (*(s+3)<<8);

				res += (res ^= ((k ^ (res << 5)) << 11)) >> 11;

				s += 4;
				len--;
			} while (len);
		}
		if (!(--j)){
			res += (*s);
			res += (res ^= (res << 10)) >> 1;
		} else if (!(--j)){
			res += *s | (*(s+1) << 8);
			res += (res ^= (res << 11)) >> 17;
		} else if (!(--j)){
			res += *s | (*(s+1) << 8 );
			res += (res ^= (((*(s+2) << 2) ^ res) << 16)) >> 11;
		}
	} else
		res = initial_val;
	if (post_process)
		res ^= (res += (res ^= (res += (res ^= res << 3) >> 5) << 2 ) >> 15) << 10;
	return res;
}

HASHKEY GetStrHash(const char *pStr, BOOL ins){
	int len = (int)StrLen(pStr);
	if (ins)
		return GetHashInsensitive(pStr, len, (unsigned long)len, TRUE);
	else
		return GetHash((unsigned char*)pStr, len, (unsigned long)len, TRUE);
}

SHARED_INLINE bool Alloc_Cache(int len){
	if (g_UnicodeLowercaseCacheSize >= len && g_pUnicodeLowercaseCache) return true;
	if (g_pUnicodeLowercaseCache){
		g_pFreeer(g_pUnicodeLowercaseCache);
		g_pUnicodeLowercaseCache = NULL;
	}
	return (g_pUnicodeLowercaseCache = (wchar_t*)g_pAllocator(((g_UnicodeLowercaseCacheSize = len)+1)*sizeof(wchar_t))) ? true : false;
}

void Free_Cache(){
	if (g_pUnicodeLowercaseCache){
		g_pFreeer(g_pUnicodeLowercaseCache);
		g_pUnicodeLowercaseCache = NULL;
	}
	g_UnicodeLowercaseCacheSize = 0;
}

HASHKEY GetStrHashW(const wchar_t *pStr, BOOL ins){
	int len = (int)StrLenW(pStr);
	if (ins && Alloc_Cache(len)){
		return GetHash((unsigned char*)_wcslwr_s((wchar_t*)StrCpyW(g_pUnicodeLowercaseCache, pStr), len), len, (unsigned long)(len*sizeof(wchar_t)), TRUE);
	}else
		return GetHash((unsigned char*)pStr, len, (unsigned long)(len*sizeof(wchar_t)), TRUE);
}

static unsigned long s_CryptTable[] = {
	0x697A5,0x6045C,0xAB4E2,0x409E4,0x71209,0x32392,0xA7292,0xB09FC,0x4B658,0xAAAD5,0x9B9CF,0xA326A,0x8DD12,0x38150,0x8E14D,0x2EB7F,
	0xE0A56,0x7E6FA,0xDFC27,0xB1301,0x8B4F7,0xA7F70,0xAA713,0x6CC0F,0x6FEDF,0x2EC87,0xC0F1C,0x45CA4,0x30DF8,0x60E99,0xBC13E,0x4E0B5,
	0x6318B,0x82679,0x26EF2,0x79C95,0x86DDC,0x99BC0,0xB7167,0x72532,0x68765,0xC7446,0xDA70D,0x9D132,0xE5038,0x2F755,0x9171F,0xCB49E,
	0x6F925,0x601D3,0x5BD8A,0x2A4F4,0x9B022,0x706C3,0x28C10,0x2B24B,0x7CD55,0xCA355,0xD95F4,0x727BC,0xB1138,0x9AD21,0xC0ACA,0xCD928,
	0x953E5,0x97A20,0x345F3,0xBDC03,0x7E157,0x96C99,0x968EF,0x92AA9,0xC2276,0xA695D,0x6743B,0x2723B,0x58980,0x66E08,0x51D1B,0xB97D2,
	0x6CAEE,0xCC80F,0x3BA6C,0xB0BF5,0x9E27B,0xD122C,0x48611,0x8C326,0xD2AF8,0xBB3B7,0xDED7F,0x4B236,0xD298F,0xBE912,0xDC926,0xC873F,
	0xD0716,0x9E1D3,0x48D94,0x9BD91,0x5825D,0x55637,0xB2057,0xBCC6C,0x460DE,0xAE7FB,0x81B03,0x34D8F,0xC0528,0xC9B59,0x3D260,0x6051D,
	0x93757,0x8027F,0xB7C34,0x4A14E,0xB12B8,0xE4945,0x28203,0xA1C0F,0xAA382,0x46ABB,0x330B9,0x5A114,0xA754B,0xC68D0,0x9040E,0x6C955,
	0xBB1EF,0x51E6B,0x9FF21,0x51BCA,0x4C879,0xDFF70,0x5B5EE,0x29936,0xB9247,0x42611,0x2E353,0x26F3A,0x683A3,0xA1082,0x67333,0x74EB7,
	0x754BA,0x369D5,0x8E0BC,0xABAFD,0x6630B,0xA3A7E,0xCDBB1,0x8C2DE,0x92D32,0x2F8ED,0x7EC54,0x572F5,0x77461,0xCB3F5,0x82C64,0x35FE0,
	0x9203B,0xADA2D,0xBAEBD,0xCB6AF,0xC8C9A,0x5D897,0xCB727,0xA13B3,0xB4D6D,0xC4929,0xB8732,0xCCE5A,0xD3E69,0xD4B60,0x89941,0x79D85,
	0x39E0F,0x6945B,0xC37F8,0x77733,0x45D7D,0x25565,0xA3A4E,0xB9F9E,0x316E4,0x36734,0x6F5C3,0xA8BA6,0xC0871,0x42D05,0x40A74,0x2E7ED,
	0x67C1F,0x28BE0,0xE162B,0xA1C0F,0x2F7E5,0xD505A,0x9FCC8,0x78381,0x29394,0x53D6B,0x7091D,0xA2FB1,0xBB942,0x29906,0xC412D,0x3FCD5,
	0x9F2EB,0x8F0CC,0xE25C3,0x7E519,0x4E7D9,0x5F043,0xBBA1B,0x6710A,0x819FB,0x9A223,0x38E47,0xE28AD,0xB690B,0x42328,0x7CF7E,0xAE108,
	0xE54BA,0xBA5A1,0xA09A6,0x9CAB7,0xDB2B3,0xA98CC,0x5CEBA,0x9245D,0x5D083,0x8EA21,0xAE349,0x54940,0x8E557,0x83EFD,0xDC504,0xA6059,
	0xB85C9,0x9D162,0x7AEB6,0xBED34,0xB4963,0xE367B,0x4C891,0x9E42C,0xD4304,0x96EAA,0xD5D69,0x866B8,0x83508,0x7BAEC,0xD03FD,0xDA122 
};

#define HASH_TYPE	(0x9C)
#define HASH_SEED1	0xDEADC0DE
#define HASH_SEED2	0x7FED7FED

unsigned long GetHash(const char* pStr){
	unsigned long lSeed1, lSeed2;
	if (!pStr)
		return 0;


	lSeed1 = HASH_SEED1;
	lSeed2 = HASH_SEED2;

	char* pKey = (char*)pStr;
	char  ch;

	while(*pKey){
 		ch = toupper (*pKey++);

 		lSeed1 = s_CryptTable[((HASH_TYPE << 8) + ch)&0xFF] ^ (lSeed1 + lSeed2);
 		lSeed2 = ch + lSeed1 + lSeed2 + (lSeed2 << 5) + 3;
	}

	return lSeed1;
}

